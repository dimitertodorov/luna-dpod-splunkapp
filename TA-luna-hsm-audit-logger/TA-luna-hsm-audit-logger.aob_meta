{"basic_builder": {"appname": "TA-luna-hsm-audit-logger", "friendly_name": "Luna HSM Audit Logger", "version": "1.0.0", "author": "Dimiter Todorov", "description": "", "theme": "#65A637", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAADLElEQVRYR+2YjTNqURTFd0K+lSENQqj4//8YEhET+SyEEJnfnreb86ire5le88aZuTN17z1nr7322ms3haTPVqjP8Eh/A9re3m7+C8a2trZaxPzF0C+gP+X4vxkaHR2VZrMpAwMD8vLyopffFZghgqbTaanX6/Lw8CAzMzNyd3cnJycnimFxcVEmJibk6upKAMq1t7cnb29vnhgDA5qenpabm5uuCQiFQgoQ0F4rMCDYIWNKxEokEhKNRvU7wV9fX+Xs7Exub2/1OYyura3pnh8DxKFTU1MyNzcn+Xxez11ZWZH7+3u5vLz8FAdgqVRKzs/PpVar6fP19XW5vr6WarXaSsbd6IuhbDYruVxOGYAJ+86BmUxGRXxwcKDnLywsyNjYmBQKBRkfH9dynZ6eKlPoiPd3d3c/JeELEGwUi0U9hJIZS0NDQwpweXlZAbA2NzdlZ2dHGaVsk5OTet80BHMGPjBDlOri4kKzfX5+1ovVDSDeQ0MGmK6kdB+XL4asRJY9hyHkSCSi7Q1DJuLZ2VllaGlpSW3BgvM++nHPCMQQPhKLxdRn4vG4ChXGELN12qd0nRuAPTo6amknmUwq2/hYIEAjIyO6GUHz+fHxUQFWKhUvHK1niJxkXDEjdjo0ECA6BurD4bAMDg7K09OTgoM57nst9z23GdCi2YHt71pDw8PDWqJSqSSuS1vmXoBcJk07lBAb+DjvugZEQBM15ra/v68YXC/qBMptcWYcSXXa5wsQnYOIXVZWV1fl8PDQs2QWnA5j/tEEnfTnCxCdcXx8rMEta7TF3EJT7RbODBDa3vUh12QDiZpNdAjujEjRFO5L66IHhI2/NBoNPR/hI1r0hrsbSzQFo2NjY6Pl9IEBkS2tOj8/r1Ob9mfKW8nMawhgwgcYmmMGsmCJsjNC2vmXr5K5mRCEWUS2ACFzfIrOYcEeWiuXy6obnlMmGx2dRBcYUDtR2qwjmA1VC0yZAWmj5ccBEQCTw0dggHHCZ7MDSsPQZcQADs25P+h+HFC7A9EUpUFrlK+nP/I9jecbDwNr6BsxPbf+AvqK2Y4MfbWxF8/7+/+hXjDwVYx3SyYuQ/BAW94AAAAASUVORK5CYII=", "visible": true, "tab_version": "4.1.1", "tab_build_no": "0", "build_no": 1}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "luna_hsm", "interval": "60", "use_external_validation": true, "streaming_mode_xml": true, "name": "luna_hsm_audit_log", "title": "Luna HSM Audit Log", "description": "", "type": "customized", "parameters": [{"name": "authentication_api_base", "label": "Authentication API Base", "help_string": "e.g. https://corp.uaa.system.snakefly.dpsas.io", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://corp.uaa.system.snakefly.dpsas.io"}, {"name": "dpod_api_base", "label": "DPOD API Base", "help_string": "e.g. https://corp.na.market.dpondemand.io", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "https://corp.na.market.dpondemand.io"}, {"name": "aggregate_event_types", "label": "Aggregate Event Types", "help_string": "Aggregate these events on each run. Aggregation will be performed on event type, client ip, partition id, and status. Optional.", "required": true, "format_type": "text", "default_value": "LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART", "placeholder": "", "type": "text", "value": "LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART"}, {"name": "client_id", "label": "Client ID", "help_string": "Luna HSM Client ID", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "5fd0aaf0-1a43-41de-a361-6b64302fe835"}, {"name": "client_secret", "label": "Client Secret", "help_string": "Luna HSM Client Secret", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "CLEANED"}], "data_inputs_options": [{"type": "customized_var", "name": "authentication_api_base", "title": "Authentication API Base", "description": "e.g. https://corp.uaa.system.snakefly.dpsas.io", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "dpod_api_base", "title": "DPOD API Base", "description": "e.g. https://corp.na.market.dpondemand.io", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "aggregate_event_types", "title": "Aggregate Event Types", "description": "Aggregate these events on each run. Aggregation will be performed on event type, client ip, partition id, and status. Optional.", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART", "placeholder": ""}, {"type": "customized_var", "name": "client_id", "title": "Client ID", "description": "Luna HSM Client ID", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "client_secret", "title": "Client Secret", "description": "Luna HSM Client Secret", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}], "customized_options": [{"name": "authentication_api_base", "value": "https://corp.uaa.system.snakefly.dpsas.io"}, {"name": "dpod_api_base", "value": "https://corp.na.market.dpondemand.io"}, {"name": "aggregate_event_types", "value": "LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART"}, {"name": "client_id", "value": "5fd0aaf0-1a43-41de-a361-6b64302fe835"}], "code": "from base64 import b64encode\nfrom bz2 import compress\nimport datetime\nfrom distutils.command.build import build\nfrom distutils.log import error\nimport gzip\nfrom io import BytesIO\n\nimport time\nimport http.client\nimport urllib.parse\nimport urllib.request\nimport logging\nimport json\n\ntry:\n    from StringIO import StringIO  # for Python 2\nexcept ImportError:\n    from io import StringIO  # for Python 3\n\ntimeout_seconds = 240\n\ndate_format = \"%Y-%m-%dT%H:%M:%SZ\"\nthales_date_format = '%Y-%m-%d %H:%M:%S %Z'\n\n\ndef get_http_connection(helper, ew, url, credentials):\n    url = urllib.parse.urlparse(url)\n    headers = {}\n    if credentials['use_proxy']:\n        proxy_host = credentials['proxy_url']\n        proxy_port = credentials['proxy_port']\n        if (credentials['proxy_username']):\n            userAndPass = credentials['proxy_username'] + \\\n                \":\" + credentials['proxy_password']\n            userAndPass = b64encode(userAndPass.encode()).decode(\"ascii\")\n            headers['Proxy-Authorization'] = \"Basic %s\", userAndPass\n        if (url.scheme == 'http'):\n            port = url.port if url.port else 80\n            conn = http.client.HTTPConnection(proxy_host, proxy_port)\n        elif (url.scheme == 'https'):\n            port = url.port if url.port else 443\n            conn = http.client.HTTPSConnection(proxy_host, proxy_port)\n        else:\n            helper.log_error(\n                \"Invalid Scheme in URL %s\", url.scheme)\n            exit(2)\n        conn.set_tunnel(url.netloc, port=port)\n    else:\n        if (url.scheme == 'http'):\n            port = url.port if url.port else 80\n            conn = http.client.HTTPConnection(url.netloc, port=port)\n        elif (url.scheme == 'https'):\n            port = url.port if url.port else 443\n            conn = http.client.HTTPSConnection(url.netloc, port=port)\n        else:\n            helper.log_error(\n                \"Invalid Scheme in URL %s\", url.scheme)\n            exit(2)\n    return conn, headers\n\n\ndef get_token(helper, ew, credentials):\n    auth_request = {\n        \"client_id\": credentials['client_id'],\n        \"client_secret\": credentials['client_secret'],\n        \"grant_type\": \"client_credentials\",\n    }\n    payload = urllib.parse.urlencode(auth_request)\n\n    conn, headers = get_http_connection(helper, ew,\n                                        credentials['authentication_api_base'], credentials)\n    headers['Accept'] = 'application/json'\n    headers['Content-Type'] = 'application/x-www-form-urlencoded'\n    try:\n        conn.request(\"POST\", \"/oauth/token\", payload, headers)\n        res = conn.getresponse()\n        if res.status != 200:\n            error_message = \"Failed getting HSM Bearer Token with response => %d : %s\" % (res.status, res.reason)\n            helper.log_error(error_message)\n            send_status_event(helper, ew, error_message, \"ERROR\")\n            exit(2)\n        else:\n            data = res.read()\n            auth_data = json.loads(data.decode(\"utf-8\"))\n            credentials['Bearer'] = auth_data[\"access_token\"]\n            return auth_data[\"access_token\"]\n    except:\n        error_message = \"Error occurred on getting the Session token from Cloud AppSec portal. %s\" % traceback.format_exc()\n        helper.log_error(error_message)\n        send_status_event(helper, ew, error_message, \"ERROR\")\n        exit(2)\n\n\ndef get_audit_logs(helper, ew, credentials, now, past):\n    conn, headers = get_http_connection(helper, ew,\n                                        credentials['dpod_api_base'], credentials)\n    headers['Accept'] = 'application/json'\n    headers['Content-Type'] = 'application/json'\n    headers['Authorization'] = \"Bearer %s\" % credentials['Bearer']\n    audit_request = {\n        \"from\": past,\n        \"to\": now\n    }\n    payload = json.dumps(audit_request)\n    response_data = {}\n    try:\n        conn.request(\"POST\", \"/v1/audit-log-exports\", payload, headers)\n        res = conn.getresponse()\n        if res.status != 201:\n            error_message = \"Failed Audit Log Export with response => %d : %s\" % (\n                res.status, res.reason)\n            helper.log_error(error_message)\n            send_status_event(helper, ew, error_message, \"ERROR\")\n            exit(2)\n        else:\n            data = res.read()\n            response_data = json.loads(data.decode(\"utf-8\"))\n    except:\n        error_message = \"Error occurred on Starting and Audit Log Export from Thales %s\" % traceback.format_exc()\n        helper.log_error(error_message)\n        send_status_event(helper, ew, error_message, \"ERROR\")\n        exit(2)\n    conn.close()\n\n    job_path = \"/v1/audit-log-exports/%s\" % response_data[\"jobId\"]\n\n    headers.pop(\"Content-Type\")\n    max_wait_times = timeout_seconds / 2\n    run_counter = 0\n    while (response_data[\"state\"] != \"SUCCEEDED\" and run_counter < max_wait_times):\n        time.sleep(2)\n        try:\n            conn.request(method=\"GET\", url=job_path, headers=headers)\n            res = conn.getresponse()\n            if res.status != 200:\n                error_message = \"Error occurred on Starting and Audit Log Export from Thales => %d : %s\" % res.status, res.reason\n                helper.log_error(error_message)\n                send_status_event(helper, ew, error_message, 'ERROR')\n                exit(2)\n            else:\n                data = res.read()\n                response_data = json.loads(data.decode(\"utf-8\"))\n        except:\n            error_message = \"Error occurred on retrieving Log Export from Thales %s\" % traceback.format_exc()\n            helper.log_error(error_message)\n            send_status_event(helper, ew, error_message, 'ERROR')\n            exit(2)\n        conn.close()\n        run_counter = run_counter+1\n    return response_data\n\n\ndef process_audit_log_events(helper, ew, credentials, url):\n    conn, headers = get_http_connection(helper, ew, url, credentials)\n    url = urllib.parse.urlsplit(url)\n    conn.request(method=\"GET\", url=\"%s?%s\" %\n                 (url.path, url.query), headers=headers)\n    response = conn.getresponse()\n    compressedFile = BytesIO(response.read())\n    conn.close()\n    decompressedFile = gzip.GzipFile(fileobj=compressedFile, mode='rb')\n    decompressedFile.seek(0)\n    aggregate_events = {}\n    while True:\n        line = decompressedFile.readline()\n        if line == b'':\n            break\n        luna_evt = json.loads(line)\n        luna_meta = json.loads(luna_evt['meta'])\n        if (credentials['aggregate_event_types'] and str(luna_evt['action']) in credentials['aggregate_event_types']):\n            aggregate_key = str(luna_evt['action'])+\":\"+str(luna_evt['status'])+\":\"+str(\n                luna_meta['clientip'])+\":\"+str(luna_meta['partid'])\n            if aggregate_key in aggregate_events:\n                aggregate_events[aggregate_key]['count'] += 1\n                aggregate_events[aggregate_key]['end_time'] = str(round(datetime.datetime.strptime(\n                    luna_evt['time'], thales_date_format).timestamp()))\n            else:\n                aggregate_events[aggregate_key] = {\n                    'count': 1,\n                    'original_event': luna_evt,\n                    'original_meta': luna_meta,\n                    'begin_time': str(round(datetime.datetime.strptime(\n                        luna_evt['time'], thales_date_format).timestamp())),\n                    'end_time': str(round(datetime.datetime.strptime(\n                        luna_evt['time'], thales_date_format).timestamp()))\n                }\n        else:\n            build_event = \"_time=\" + \\\n                str(round(datetime.datetime.strptime(\n                    luna_evt['time'], thales_date_format).timestamp()))+\",\"\n            build_event = build_event + \"resourceID=\" + \\\n                str(luna_evt['resourceID'])+','\n            build_event = build_event + \"clientid=\"+str(credentials['client_id'])+','\n            build_event = build_event + \"actorID=\"+str(luna_evt['actorID'])+','\n            build_event = build_event + \"tenantID=\" + \\\n                str(luna_evt['tenantID'])+','\n            build_event = build_event + \"action=\"+str(luna_evt['action'])+','\n            build_event = build_event + \"status=\"+str(luna_evt['status'])+','\n            build_event = build_event + \"clientip=\" + \\\n                str(luna_meta['clientip'])+','\n            build_event = build_event + \"hsmid=\"+str(luna_meta['hsmid'])+','\n            build_event = build_event + \"partid=\"+str(luna_meta['partid'])+','\n            event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(\n            ), sourcetype=helper.get_sourcetype(), data=build_event)\n            ew.write_event(event)\n\n    # Iterate through aggregated events and write to stream\n    for agg_key in aggregate_events:\n        luna_evt = aggregate_events[agg_key]['original_event']\n        luna_meta = aggregate_events[agg_key]['original_meta']\n        build_event = \"_time=\" + \\\n            str(round(datetime.datetime.strptime(\n                luna_evt['time'], thales_date_format).timestamp()))+\",\"\n        build_event = build_event + \"clientid=\"+str(credentials['client_id'])+','\n        build_event = build_event + \"resourceID=\" + \\\n            str(luna_evt['resourceID'])+','\n        build_event = build_event + \"actorID=\"+str(luna_evt['actorID'])+','\n        build_event = build_event + \"tenantID=\" + \\\n            str(luna_evt['tenantID'])+','\n        build_event = build_event + \"action=\"+str(luna_evt['action'])+','\n        build_event = build_event + \"status=\"+str(luna_evt['status'])+','\n        build_event = build_event + \"clientip=\" + \\\n            str(luna_meta['clientip'])+','\n        build_event = build_event + \"hsmid=\"+str(luna_meta['hsmid'])+','\n        build_event = build_event + \"partid=\"+str(luna_meta['partid'])+','\n        build_event = build_event + \"count=\" + \\\n            str(aggregate_events[agg_key]['count'])\n        event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(\n        ), sourcetype=helper.get_sourcetype(), data=build_event)\n        ew.write_event(event)\n\n\ndef send_status_event(helper, ew, message, status=\"INFO\"):\n    build_event = \"_time=\" + \\\n        str(round(datetime.datetime.now().timestamp())) + \",\"\n    build_event = build_event + \"clientid=\"+str(helper.get_arg('client_id'))+','\n    build_event = build_event + \"message=\" + json.dumps(message)\n    build_event = build_event + \",severity=\" + status\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(\n    ), sourcetype=helper.get_sourcetype(), data=build_event)\n    ew.write_event(event)\n\n\ndef validate_input(helper, definition):\n    pass\n\n\ndef collect_events(helper, ew):\n    send_status_event(helper, ew, \"Starting Log Collection from %s,client_id=%s\" % (\n        helper.get_arg('dpod_api_base'), helper.get_arg('client_id')))\n    now_checkpoint = str(round(time.time()))\n    now = int(round(time.time()))\n    interval = int(helper.get_arg('interval'))\n    past = now - interval\n    now = datetime.datetime.fromtimestamp(now).strftime(date_format)\n    past = datetime.datetime.fromtimestamp(past).strftime(date_format)\n    credentials = {\n        \"authentication_api_base\": helper.get_arg('authentication_api_base'),\n        \"dpod_api_base\": helper.get_arg('dpod_api_base'),\n        \"Bearer\": \"\",\n        \"client_id\": helper.get_arg('client_id'),\n        \"client_secret\": helper.get_arg('client_secret'),\n        \"proximity\": \"\",\n        \"use_proxy\": False,\n        \"aggregate_event_types\": []\n    }\n    if (helper.get_arg('aggregate_event_types')):\n        credentials['aggregate_event_types'] = str(\n            helper.get_arg('aggregate_event_types')).split(',')\n\n    proxy_settings = helper.get_proxy()\n    if (proxy_settings):\n        credentials['use_proxy'] = True\n        credentials['proxy_url'] = proxy_settings['proxy_url']\n        credentials['proxy_port'] = proxy_settings['proxy_port']\n        credentials['proxy_type'] = proxy_settings['proxy_type']\n        credentials['proxy_username'] = proxy_settings['proxy_username']\n        credentials['proxy_password'] = proxy_settings['proxy_password']\n        credentials['proxy_rdns'] = proxy_settings['proxy_rdns']\n    # Get the autherization token for the app, using the client_id and secret\n    get_token(helper, ew, credentials)\n    audit_logs = get_audit_logs(helper, ew, credentials, now, past)\n    helper.save_check_point(\"last_run_%s\" %\n                            helper.get_arg('client_id'), now_checkpoint)\n    send_status_event(helper, ew, \"Luna HSM log processing completed.\")\n    process_audit_log_events(helper, ew, credentials, audit_logs['location'])\n", "uuid": "7958f5a4e990494b9a8be94510d9c53d", "sample_count": "1598"}]}, "field_extraction_builder": {"luna_hsm": {"data_format": "unstructured_data"}}, "global_settings_builder": {"global_settings": {"proxy_settings": {"proxy_type": "http"}, "log_settings": {"log_level": "DEBUG"}}}, "sourcetype_builder": {"luna_hsm": {"metadata": {"event_count": 0, "data_input_name": "luna_hsm_audit_log", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1666980319_75", "progress": 1.0}}