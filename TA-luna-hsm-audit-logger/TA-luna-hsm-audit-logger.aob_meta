{"basic_builder":{"appname":"TA-luna-hsm-audit-logger","friendly_name":"Luna HSM Audit Logger","version":"1.0.5","author":"Dimiter Todorov","description":"","theme":"#65A637","large_icon":"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","small_icon":"iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAMAAADW3miqAAAB4FBMVEUAAAAUG0oWGkkTGkoVHEgTG0gSEkkTHUgUHEkUG0kUG0kTHEgTHEkVGUsVHEwVHEkVHEoVG0oVGUgUG0kUG0gTG0oXHksUHEkUHEoUG0oUG0kXF0YUHUoTG0gNG0MTGUsTG0kWG0cVG0kSG0gQGUoUHEkUGkgUG0kUG0kUHEoUGkgRHUsTGkkABSACAiICAyICAyICAiIUHEkUGkkNDTwCAyICBCICAyECAiITHEoCBCMAACADAyMVGkkTG0kUG0kCBCQUG0oVHEcJCy0EBCQUFE4CAyIBAyEKDTEPFT4KDDIABCAAACABAyICBCIVGkoFBygGBykDBCQDAyMDAyMTHEgUG0oUGUsNEzoEBScJDTIDBicUG0oUGkoFBygGCCoHCCwBAyECAyIWHEoLDzULDzYVGkoDBCMHCy4HCCsVHEoEBicEBygLDzUKDzYAAFUUGkcJCzEOHEcJCzESGEUUG0gTG0gUG0kHCS0EBygTG0gTGkgTHEsSHEoUHEgUHEkUG0gCAiICBCMLEDgVGkkVIEoTHEgUHEkUGkgSGkYVGkkTG0gUGkgkJEkaGk0VG0oYGEkUHEkTG0kWHEgUH0cVHEoVHEgTHEwXH00UGkkRGUwVHEggIEAVGkgVHEUQIEC6dni6AAAAoHRSTlMAJjtPY2AONVuMmVx2PSVtblY8lphdIoFkTJcWNIYTKZAvejkfiSd9glpZLGwwz//vf2V+JuCAoHA3dCDAYl6Pho4kWkAN37+grGs/EK+Qh8Dl+VBgUnIzs+zAW2hZ39+XsPBTeaZhxdO+b7nmv2QDMswSh5+NX3Nx5YNqUlOKZnJv1Y1XGFGLgB0xQ04HCjAVP0IuGUhuNiF0HkoIYyUQMrTbbQAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAi5JREFUeJx9lIlX00AQxlMrgoNQKqIW1HIEFUuy8SANNq2KoXjEKm211PsWbzwQT/BArRY88L7/VWe3aboJDfNest9++8vMZN8mguAI3yL/4polwgJRW7cUaNQvgCwDKxq8kMYAW2/CK+jFLG/G1RUtK1cBrPZiQoi0+tuENQBr13kwYWTaO1B0AnR5MCIy3etpUYANXsXw+Y0iFT0AmzyYBkwUYaoXwCfJRNlcNdGWktoKsE3pU6NEczP9mKixJNsBtpOYIOiyG4oDJCy5A2AnwVElbmgXwECl8G4VR0N1MT6sNkiFlBzaA3v37S+FKR2QUzaEe3OQCVM1Dg2niRVyXyZr2NBhgCNlnRvJHz2GhG4SLcaXOw5wwpKp5Mn0qdPkzFlFIvKQ4oTOWVLKns/nLxAzGs0QzeD3CstdLGvpUpqMXjb0mEJkxwti41dKSksmM1evjV6/kZJ0PavLXD3cguabVjVstgXKp8XIcqnw8I9x0yYgt+pvuzZTqOOaonGHDN8dvxe2K4Um8F6LBUQOIvcfjKD18FHi8ZOa3kmUU+g+dX5p5NnzF+CIaXQjOOYqkKZHzZevXleYArMTqN64Wx0U3xaLuRlc8rH5bAHlOzdFI4gLfku30azv5yEf8DxCwJ4OsP+E6GQ+dqM5xxmzcYZ9so3PX75Sp8P5XGicmpM9xW/h/lC8wN6r8/u8DoKtzu35UfWL//lrooIExqohLH5H5qYDf2a6/v7j3f8KtV/TSOoq1QAAAABJRU5ErkJggg==","visible":true,"tab_version":"4.1.1","tab_build_no":"0","build_no":1},"data_input_builder":{"datainputs":[{"index":"default","sourcetype":"luna_hsm","interval":"60","use_external_validation":true,"streaming_mode_xml":true,"name":"luna_hsm_audit_log","title":"Luna HSM Audit Log","description":"","type":"customized","parameters":[{"name":"authentication_api_base","label":"Authentication API Base","help_string":"e.g. https://corp.uaa.system.snakefly.dpsas.io","required":true,"format_type":"text","default_value":"","placeholder":"","type":"text","value":"https://corp.uaa.system.snakefly.dpsas.io"},{"name":"dpod_api_base","label":"DPOD API Base","help_string":"e.g. https://corp.na.market.dpondemand.io","required":true,"format_type":"text","default_value":"","placeholder":"","type":"text","value":"https://corp.na.market.dpondemand.io"},{"name":"aggregate_event_types","label":"Aggregate Event Types","help_string":"Aggregate these events on each run. Aggregation will be performed on event type, client ip, partition id, and status. Optional.","required":true,"format_type":"text","default_value":"LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART","placeholder":"","type":"text","value":"LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART"},{"name":"client_id","label":"Client ID","help_string":"Luna HSM Client ID","required":true,"format_type":"text","default_value":"","placeholder":"","type":"text","value":"5fd0aaf0-1a43-41de-a361-6b64302fe835"},{"name":"client_secret","label":"Client Secret","help_string":"Luna HSM Client Secret","required":true,"format_type":"password","default_value":"","placeholder":"","type":"password","value":"CLEANED"}],"data_inputs_options":[{"type":"customized_var","name":"authentication_api_base","title":"Authentication API Base","description":"e.g. https://corp.uaa.system.snakefly.dpsas.io","required_on_edit":false,"required_on_create":true,"format_type":"text","default_value":"","placeholder":""},{"type":"customized_var","name":"dpod_api_base","title":"DPOD API Base","description":"e.g. https://corp.na.market.dpondemand.io","required_on_edit":false,"required_on_create":true,"format_type":"text","default_value":"","placeholder":""},{"type":"customized_var","name":"aggregate_event_types","title":"Aggregate Event Types","description":"Aggregate these events on each run. Aggregation will be performed on event type, client ip, partition id, and status. Optional.","required_on_edit":false,"required_on_create":true,"format_type":"text","default_value":"LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART","placeholder":""},{"type":"customized_var","name":"client_id","title":"Client ID","description":"Luna HSM Client ID","required_on_edit":false,"required_on_create":true,"format_type":"text","default_value":"","placeholder":""},{"type":"customized_var","name":"client_secret","title":"Client Secret","description":"Luna HSM Client Secret","required_on_edit":false,"required_on_create":true,"format_type":"password","default_value":"","placeholder":""}],"customized_options":[{"name":"authentication_api_base","value":"https://corp.uaa.system.snakefly.dpsas.io"},{"name":"dpod_api_base","value":"https://corp.na.market.dpondemand.io"},{"name":"aggregate_event_types","value":"LUNA_DECRYPT_SINGLEPART,LUNA_VERIFY_SINGLEPART"},{"name":"client_id","value":"5fd0aaf0-1a43-41de-a361-6b64302fe835"}],"code":"import datetime\r\nimport gzip\r\nimport http.client\r\nimport json\r\nimport time\r\nimport traceback\r\nimport urllib.parse\r\nimport urllib.request\r\nfrom base64 import b64encode\r\nfrom bz2 import compress\r\nfrom distutils.log import error\r\nfrom io import BytesIO\r\n\r\ntimeout_seconds = 240\r\n\r\ndate_format = \"%Y-%m-%dT%H:%M:%SZ\"\r\nthales_date_format = '%Y-%m-%d %H:%M:%S %Z'\r\n\r\n\r\nclass LunaCloudHsmProcessor:\r\n    def __init__(self, helper, ew, definition=None, validate_only=False):\r\n        self.helper = helper\r\n        self.ew = ew\r\n        self.definition = definition\r\n        self.access_token = None\r\n\r\n        if validate_only:\r\n            self.auth_url = urllib.parse.urlparse(self.definition.parameters.get(\r\n                'authentication_api_base', None))\r\n            self.api_url = urllib.parse.urlparse(\r\n                self.definition.parameters.get('dpod_api_base', None))\r\n        else:\r\n            self.auth_url = urllib.parse.urlparse(\r\n                helper.get_arg('authentication_api_base'))\r\n            self.api_url = urllib.parse.urlparse(\r\n                helper.get_arg('dpod_api_base'))\r\n            self.properties = {\r\n                \"authentication_api_base\": helper.get_arg('authentication_api_base'),\r\n                \"dpod_api_base\": helper.get_arg('dpod_api_base'),\r\n                \"Bearer\": \"\",\r\n                \"client_id\": helper.get_arg('client_id'),\r\n                \"client_secret\": helper.get_arg('client_secret'),\r\n                \"proximity\": \"\",\r\n                \"use_proxy\": False,\r\n                \"aggregate_event_types\": []\r\n            }\r\n            if (helper.get_arg('aggregate_event_types')):\r\n                self.properties['aggregate_event_types'] = str(\r\n                    helper.get_arg('aggregate_event_types')).split(',')\r\n\r\n            proxy_settings = helper.get_proxy()\r\n            if (proxy_settings):\r\n                self.properties['use_proxy'] = True\r\n                self.properties['proxy_url'] = proxy_settings['proxy_url']\r\n                self.properties['proxy_port'] = proxy_settings['proxy_port']\r\n                self.properties['proxy_type'] = proxy_settings['proxy_type']\r\n                self.properties['proxy_username'] = proxy_settings['proxy_username']\r\n                self.properties['proxy_password'] = proxy_settings['proxy_password']\r\n                self.properties['proxy_rdns'] = proxy_settings['proxy_rdns']\r\n\r\n    def validate_input(self):\r\n        try:\r\n            assert (self.auth_url.scheme.lower() == \"https\")\r\n            assert (self.api_url.scheme.lower() == \"https\")\r\n        except Exception as err:\r\n            error_message = \"Validation Exception Occured %s\" % err.__class__.__qualname__\r\n            self.helper.log_error(error_message)\r\n            self.helper.log_error(\"Trace: %s\" %\r\n                                  traceback.format_exception(err))\r\n            exit(2)\r\n\r\n    # Send a status event to Splunk\r\n    def send_status_event(self, message, status=\"INFO\"):\r\n        build_event = \"_time=\" + \\\r\n            str(round(datetime.datetime.now().timestamp())) + \",\"\r\n        build_event = build_event + \"clientid=\" + \\\r\n            str(self.helper.get_arg('client_id'))+','\r\n        build_event = build_event + \"message=\" + json.dumps(message)\r\n        build_event = build_event + \",severity=\" + status\r\n        event = self.new_event(source=self.helper.get_input_type(), index=self.helper.get_output_index(\r\n        ), sourcetype=self.helper.get_sourcetype(), data=build_event)\r\n        self.ew.write_event(event)\r\n\r\n    # Get a token from Thales Auth endpoint\r\n    def get_token(self):\r\n        auth_request = {\r\n            \"client_id\": self.properties['client_id'],\r\n            \"client_secret\": self.properties['client_secret'],\r\n            \"grant_type\": \"client_credentials\",\r\n        }\r\n        payload = urllib.parse.urlencode(auth_request)\r\n\r\n        conn, headers = self.get_http_connection(self.auth_url.geturl())\r\n        headers['Accept'] = 'application/json'\r\n        headers['Content-Type'] = 'application/x-www-form-urlencoded'\r\n        try:\r\n            conn.request(\"POST\", \"/oauth/token\", payload, headers)\r\n            res = conn.getresponse()\r\n            if res.status != 200:\r\n                error_message = \"Failed getting HSM Bearer Token with response => %d : %s\" % (\r\n                    res.status, res.reason)\r\n                self.helper.log_error(error_message)\r\n                self.send_status_event(error_message, \"ERROR\")\r\n                exit(2)\r\n            else:\r\n                data = res.read()\r\n                auth_data = json.loads(data.decode(\"utf-8\"))\r\n                self.access_token = auth_data[\"access_token\"]\r\n                return auth_data[\"access_token\"]\r\n        except Exception as err:\r\n            error_message = \"Error occurred on getting the Session token from Cloud AppSec portal. %s\" % err.__class__.__qualname__\r\n            self.helper.log_error(error_message)\r\n            self.helper.log_error(\"Trace: %s\" %\r\n                                  traceback.format_exception(err))\r\n            self.send_status_event(error_message, \"ERROR\")\r\n            exit(2)\r\n\r\n    # Custom function to set up HTTP Connections. Proxy compatible\r\n    def get_http_connection(self, url):\r\n        url = urllib.parse.urlparse(url)\r\n        headers = {}\r\n        if self.properties['use_proxy']:\r\n            proxy_host = self.properties['proxy_url']\r\n            proxy_port = self.properties['proxy_port']\r\n            if (self.properties['proxy_username']):\r\n                userAndPass = self.properties['proxy_username'] + \\\r\n                    \":\" + self.properties['proxy_password']\r\n                userAndPass = b64encode(userAndPass.encode()).decode(\"ascii\")\r\n                headers['Proxy-Authorization'] = \"Basic %s\", userAndPass\r\n            if (url.scheme == 'https'):\r\n                port = url.port if url.port else 443\r\n                conn = http.client.HTTPSConnection(proxy_host, proxy_port)\r\n            else:\r\n                self.helper.log_error(\r\n                    \"Invalid Scheme in URL - %s. Only HTTPS supported.\", url.geturl())\r\n                exit(2)\r\n            conn.set_tunnel(url.netloc, port=port)\r\n        else:\r\n            if (url.scheme == 'https'):\r\n                port = url.port if url.port else 443\r\n                conn = http.client.HTTPSConnection(url.hostname, port=port)\r\n            else:\r\n                self.helper.log_error(\r\n                    \"Invalid Scheme in URL - %s. Only HTTPS supported.\", url.geturl())\r\n                exit(2)\r\n        return conn, headers\r\n\r\n    # This function uses the DPOD Audit Query API to collect logs from DPOD Cloud HSM\r\n    # Returns the location of the audit logs in the URL\r\n    def get_audit_logs(self, now, past):\r\n        conn, headers = self.get_http_connection(self.api_url.geturl())\r\n        headers['Accept'] = 'application/json'\r\n        headers['Content-Type'] = 'application/json'\r\n        headers['Authorization'] = \"Bearer %s\" % self.access_token\r\n        audit_request = {\r\n            \"from\": past,\r\n            \"to\": now\r\n        }\r\n        payload = json.dumps(audit_request)\r\n        response_data = {}\r\n        try:\r\n            conn.request(\"POST\", \"/v1/audit-log-exports\", payload, headers)\r\n            res = conn.getresponse()\r\n            if res.status != 201:\r\n                error_message = \"Failed Audit Log Export with response => %d : %s\" % (\r\n                    res.status, res.reason)\r\n                self.helper.log_error(error_message)\r\n                self.send_status_event(error_message, \"ERROR\")\r\n                exit(2)\r\n            else:\r\n                data = res.read()\r\n                response_data = json.loads(data.decode(\"utf-8\"))\r\n        except Exception as err:\r\n            error_message = \"Error occurred on Starting and Audit Log Export from Thales %s\" % err.__class__.__qualname__\r\n            self.helper.log_error(error_message)\r\n            self.helper.log_error(\"Trace: %s\" %\r\n                                  traceback.format_exception(err))\r\n            self.send_status_event(error_message, \"ERROR\")\r\n            exit(2)\r\n        conn.close()\r\n\r\n        # Start polling for audit-log-export in DPOD API\r\n        job_path = \"/v1/audit-log-exports/%s\" % response_data[\"jobId\"]\r\n        headers.pop(\"Content-Type\")\r\n\r\n        max_wait_times = timeout_seconds / 2\r\n        run_counter = 0\r\n        while (response_data[\"state\"] != \"SUCCEEDED\" and run_counter < max_wait_times):\r\n            time.sleep(2)\r\n            try:\r\n                conn.request(method=\"GET\", url=job_path, headers=headers)\r\n                res = conn.getresponse()\r\n                if res.status != 200:\r\n                    error_message = \"Error occurred on Starting and Audit Log Export from Thales => %d : %s\" % res.status, res.reason\r\n                    self.helper.log_error(error_message)\r\n                    self.send_status_event(error_message, 'ERROR')\r\n                    exit(2)\r\n                else:\r\n                    data = res.read()\r\n                    response_data = json.loads(data.decode(\"utf-8\"))\r\n            except Exception as err:\r\n                error_message = \"Error occurred on retrieving Log Export from Thales %s\" % err.__class__.__qualname__\r\n                self.helper.log_error(error_message)\r\n                self.helper.log_error(\"Trace: %s\" %\r\n                                      traceback.format_exception(err))\r\n                self.send_status_event(error_message, 'ERROR')\r\n                exit(2)\r\n            conn.close()\r\n            run_counter = run_counter+1\r\n        return response_data\r\n\r\n    # Processes an audit log .gzip from DPOD Audit Query API\r\n    # Will aggregate events depending on input configuration\r\n    def process_audit_log_events(self, url):\r\n        conn, headers = self.get_http_connection(url)\r\n        url = urllib.parse.urlsplit(url)\r\n        conn.request(method=\"GET\", url=\"%s?%s\" %\r\n                     (url.path, url.query), headers=headers)\r\n        response = conn.getresponse()\r\n        compressedFile = BytesIO(response.read())\r\n        conn.close()\r\n        decompressedFile = gzip.GzipFile(fileobj=compressedFile, mode='rb')\r\n        decompressedFile.seek(0)\r\n        aggregate_events = {}\r\n        while True:\r\n            line = decompressedFile.readline()\r\n            if line == b'':\r\n                break\r\n            luna_evt = json.loads(line)\r\n            luna_meta = json.loads(luna_evt['meta'])\r\n            if (self.properties['aggregate_event_types'] and str(luna_evt['action']) in self.properties['aggregate_event_types']):\r\n                aggregate_key = str(luna_evt['action'])+\":\"+str(luna_evt['status'])+\":\"+str(\r\n                    luna_meta['clientip'])+\":\"+str(luna_meta['partid'])\r\n                if aggregate_key in aggregate_events:\r\n                    aggregate_events[aggregate_key]['count'] += 1\r\n                    aggregate_events[aggregate_key]['end_time'] = str(round(datetime.datetime.strptime(\r\n                        luna_evt['time'], thales_date_format).timestamp()))\r\n                else:\r\n                    aggregate_events[aggregate_key] = {\r\n                        'count': 1,\r\n                        'original_event': luna_evt,\r\n                        'original_meta': luna_meta,\r\n                        'begin_time': str(round(datetime.datetime.strptime(\r\n                            luna_evt['time'], thales_date_format).timestamp())),\r\n                        'end_time': str(round(datetime.datetime.strptime(\r\n                            luna_evt['time'], thales_date_format).timestamp()))\r\n                    }\r\n            else:\r\n                build_event = \"_time=\" + \\\r\n                    str(round(datetime.datetime.strptime(\r\n                        luna_evt['time'], thales_date_format).timestamp()))+\",\"\r\n                build_event = build_event + \"resourceID=\" + \\\r\n                    str(luna_evt['resourceID'])+','\r\n                build_event = build_event + \"clientid=\" + \\\r\n                    str(self.properties['client_id'])+','\r\n                build_event = build_event + \"actorID=\" + \\\r\n                    str(luna_evt['actorID'])+','\r\n                build_event = build_event + \"tenantID=\" + \\\r\n                    str(luna_evt['tenantID'])+','\r\n                build_event = build_event + \"action=\" + \\\r\n                    str(luna_evt['action'])+','\r\n                build_event = build_event + \"status=\" + \\\r\n                    str(luna_evt['status'])+','\r\n                build_event = build_event + \"clientip=\" + \\\r\n                    str(luna_meta['clientip'])+','\r\n                build_event = build_event + \"hsmid=\" + \\\r\n                    str(luna_meta['hsmid'])+','\r\n                build_event = build_event + \"partid=\" + \\\r\n                    str(luna_meta['partid'])\r\n                event = self.new_event(source=self.helper.get_input_type(), index=self.helper.get_output_index(\r\n                ), sourcetype=self.helper.get_sourcetype(), data=build_event)\r\n                self.ew.write_event(event)\r\n\r\n        # Iterate through aggregated events and write to stream\r\n        for agg_key in aggregate_events:\r\n            luna_evt = aggregate_events[agg_key]['original_event']\r\n            luna_meta = aggregate_events[agg_key]['original_meta']\r\n            build_event = \"_time=\" + \\\r\n                str(round(datetime.datetime.strptime(\r\n                    luna_evt['time'], thales_date_format).timestamp()))+\",\"\r\n            build_event = build_event + \"clientid=\" + \\\r\n                str(self.properties['client_id'])+','\r\n            build_event = build_event + \"resourceID=\" + \\\r\n                str(luna_evt['resourceID'])+','\r\n            build_event = build_event + \"actorID=\"+str(luna_evt['actorID'])+','\r\n            build_event = build_event + \"tenantID=\" + \\\r\n                str(luna_evt['tenantID'])+','\r\n            build_event = build_event + \"action=\"+str(luna_evt['action'])+','\r\n            build_event = build_event + \"status=\"+str(luna_evt['status'])+','\r\n            build_event = build_event + \"clientip=\" + \\\r\n                str(luna_meta['clientip'])+','\r\n            build_event = build_event + \"hsmid=\"+str(luna_meta['hsmid'])+','\r\n            build_event = build_event + \"partid=\"+str(luna_meta['partid'])+','\r\n            build_event = build_event + \"count=\" + \\\r\n                str(aggregate_events[agg_key]['count'])\r\n            event = self.new_event(source=self.helper.get_input_type(), index=self.helper.get_output_index(\r\n            ), sourcetype=self.helper.get_sourcetype(), data=build_event)\r\n            self.ew.write_event(event)\r\n\r\n    # Wrapper function to help create events.\r\n    def new_event(self, data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True):\r\n        \"\"\"Create a Splunk event object. - Wrapper around the TA Helper to insert the DPOD Host if not provided in the event\r\n\r\n        :param data: ``string``, the event's text.\r\n        :param time: ``float``, time in seconds, including up to 3 decimal places to represent milliseconds.\r\n        :param host: ``string``, the event's host, ex: localhost.\r\n        :param index: ``string``, the index this event is specified to write to, or None if default index.\r\n        :param source: ``string``, the source of this event, or None to have Splunk guess.\r\n        :param sourcetype: ``string``, source type currently set on this event, or None to have Splunk guess.\r\n        :param done: ``boolean``, is this a complete ``Event``? False if an ``Event`` fragment.\r\n        :param unbroken: ``boolean``, Is this event completely encapsulated in this ``Event`` object?\r\n        :return: ``Event`` object\r\n        \"\"\"\r\n        data += f\",input_config={self.helper.get_input_stanza_names()}\"\r\n        if host:\r\n            return self.helper.new_event(data, time=time, host=host, index=index, source=index, sourcetype=sourcetype, done=True, unbroken=True)\r\n        else:\r\n            return self.helper.new_event(data, time=time, host=self.api_url.hostname, index=index, source=index, sourcetype=sourcetype, done=True, unbroken=True)\r\n\r\n\r\ndef validate_input(helper, definition):\r\n    validator = LunaCloudHsmProcessor(helper, None, definition, True)\r\n    validator.validate_input()\r\n\r\n\r\ndef collect_events(helper, ew):\r\n    processor = LunaCloudHsmProcessor(helper, ew, None, False)\r\n\r\n    processor.send_status_event(\"Starting Log Collection from %s,client_id=%s\" % (\r\n        helper.get_arg('dpod_api_base'), helper.get_arg('client_id')))\r\n\r\n    # Get the auth token for the app using client_id and client_secret\r\n    processor.get_token()\r\n\r\n    # Get time window to filter for logs\r\n    now_checkpoint = str(round(time.time()))\r\n    last_checkpoint = helper.get_check_point(\"last_run_%s\" %\r\n                                             helper.get_arg('client_id'))\r\n    interval = int(helper.get_arg('interval'))\r\n\r\n    now = int(round(time.time()))\r\n    past = now - interval\r\n\r\n    # Check the last run checkpoint if set and use that as the 'from' parameter to Thales. \r\n    # Make sure the interval is not more than 30 days\r\n    if last_checkpoint and ((past > int(last_checkpoint)) and ((now - int(last_checkpoint)) < 2591998)):\r\n        past = datetime.datetime.fromtimestamp(\r\n            int(last_checkpoint)).strftime(date_format)\r\n    else:\r\n        past = datetime.datetime.fromtimestamp(past).strftime(date_format)\r\n    now = datetime.datetime.fromtimestamp(now).strftime(date_format)\r\n\r\n    # Request an audit log export from DPOD API\r\n    audit_logs = processor.get_audit_logs(now, past)\r\n\r\n    # Process resultant .gzip file into events\r\n    processor.process_audit_log_events(audit_logs['location'])\r\n\r\n    processor.send_status_event(\"Luna HSM log processing completed.\")\r\n\r\n    # Save Checkpoint - only save once all steps have finished.\r\n    helper.save_check_point(\"last_run_%s\" %\r\n                            helper.get_arg('client_id'), now_checkpoint)\r\n","uuid":"7958f5a4e990494b9a8be94510d9c53d","sample_count":"1598"}]},"field_extraction_builder":{"luna_hsm":{"data_format":"unstructured_data"}},"global_settings_builder":{"global_settings":{"proxy_settings":{"proxy_type":"http"},"log_settings":{"log_level":"DEBUG"}}},"sourcetype_builder":{"luna_hsm":{"metadata":{"event_count":0,"data_input_name":"luna_hsm_audit_log","extractions_count":0,"cims_count":0}}},"validation":{"validators":["best_practice_validation","data_model_mapping_validation","field_extract_validation","app_cert_validation"],"status":"job_finished","validation_id":"v_1666980319_75","progress":1}}
